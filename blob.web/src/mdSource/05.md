---
title: Objective-C | UI
tag: iOS
date: 2016-03-11
---

### **UILaber**

```
lable = [[UILabel alloc]initWithFrame:CGRectMake(0, 20, 375,30)];
lable.backgroundColor = [UIColor grayColor];
lable.text = @“laber”;
lable.textColor = [UIColor whiteColor];
lable.backgroudColor=[UIColor clearColor]; 
lable.textAlignment = NSTextAlignmentCenter;
//设置字体大小适应label宽度
lable.adjustsFontSizeToFitWidth = YES;
lable.font = [UIFont systemFontOfSize:18];
//字体大小，粗细
lable.font = [UIFont systemFontOfSize:18 weight:UIFontWeightThin];
//字体加粗，并设置字号
lable.font = [UIFont boldSystemFontOfSize:25];
//字体倾斜，并设置字号，对中文无效
lable.font = [UIFont italicSystemFontOfSize:25];
//设置高亮 
lable.highlighted = YES;     
lable.highlightedTextColor = [UIColor orangeColor];
//设置阴影
lable.shadowColor = [UIColor redColor];     
lable.shadowOffset = CGSizeMake(1.0,1.0); //偏移量
//设置是否能与用户进行交互     
lable.userInteractionEnabled = YES;   
//设置label中的文字是否可变，默认值是YES     
lable.enabled = NO;
//文字显示的最大行数
lable.numberofLines = 0
//numberofLines = 0 时设置文字过长时的显示格式     
lable.lineBreakMode = UILineBreakModeMiddleTruncation;//截去中间
```

### **UITextField**

```
UITextField *textField = [[UITextField alloc]initWithFrame:CGRectMake(20, 100, 335, 34)];
//文本框的边框设定 个人觉得最后一种最好看
textField.borderStyle = UITextBorderStyleLine;
		    								UITextBorderStyleNone,
    		    						UITextBorderStyleLine,
   		    							UITextBorderStyleBezel,
  		    							UITextBorderStyleRoundedRect
//文本框内默认文字
textField.text = @“11”;
//文本框内提示文字
textField.placeholder = @"请输入文本";
//设置输入框内容的字体样式和大小
textField.font = [UIFont fontWithName:@"Arial" size:20];
//设置字体颜色
textField.textColor = [UIColor redColor];
//设置输入框的背景颜色，如果使用了自定义的背景图片边框会被忽略掉　
textField.backgroundColor = [UIColor whiteColor];
//设置背景
textField.background = [UIImage imageNamed:@"dd.png"];
//设置disabled状态的背景 
textField.disabledBackground = [UIImage imageNamed:@"cc.png"];
//设置清除按钮模式
textField.clearButtonMode = UITextFieldViewModeAlways;
    												UITextFieldViewModeNever,　从不出现
    												UITextFieldViewModeWhileEditing, 编辑时出现
    												UITextFieldViewModeUnlessEditing,　除了编辑外都出现
    												UITextFieldViewModeAlways 　一直出现
//是否纠错
textField.autocorrectionType = UITextAutocorrectionTypeNo;
    													 UITextAutocorrectionTypeDefault, 默认
    													 UITextAutocorrectionTypeNo, 　不自动纠错
    													 UITextAutocorrectionTypeYes,　自动纠错
//再次编辑就清空
textField.clearsOnBeginEditing = YES;
//内容对齐方式
textField.textAlignment = NSTextAlignmentLeft; // center/right
//内容的垂直对齐方式
textField.contentVerticalAlignment = UIControlContentVerticalAlignmentCenter;
//设置为YES时文本会自动缩小以适应文本窗口大小.默认是保持原来大小,而让长文本滚动　
textFied.adjustsFontSizeToFitWidth = YES;
//设置自动缩小显示的最小字体大小
textField.minimumFontSize = 20;
//设置键盘的样式
textField.keyboardType = UIKeyboardTypeNumberPad;
    UIKeyboardTypeDefault,     　默认键盘，支持所有字符         
    UIKeyboardTypeASCIICapable,　支持ASCII的默认键盘
    UIKeyboardTypeNumbersAndPunctuation,　标准电话键盘，支持＋＊＃字符
    UIKeyboardTypeURL,            URL键盘，支持.com按钮 只支持URL字符
    UIKeyboardTypeNumberPad,            　数字键盘
    UIKeyboardTypePhonePad,　 　电话键盘
    UIKeyboardTypeNamePhonePad, 　电话键盘，也支持输入人名
    UIKeyboardTypeEmailAddress, 　用于输入电子 邮件地址的键盘     
    UIKeyboardTypeDecimalPad,   　数字键盘 有数字和小数点
    UIKeyboardTypeTwitter,      　优化的键盘，方便输入@、#字符
//首字母是否大写
text.autocapitalizationType = UITextAutocapitalizationTypeNone;
    UITextAutocapitalizationTypeNone, 不自动大写
    UITextAutocapitalizationTypeWords,　单词首字母大写
    UITextAutocapitalizationTypeSentences,　句子的首字母大写
    UITextAutocapitalizationTypeAllCharacters, 所有字母都大写
//return键变成什么键
text.returnKeyType =UIReturnKeyDone;
    UIReturnKeyDefault, 默认 灰色按钮，标有Return
    UIReturnKeyGo,    　标有Go的蓝色按钮
    UIReturnKeyGoogle,标有Google的蓝色按钮，用语搜索
    UIReturnKeyJoin,标有Join的蓝色按钮
    UIReturnKeyNext,标有Next的蓝色按钮
    UIReturnKeyRoute,标有Route的蓝色按钮
    UIReturnKeySearch,标有Search的蓝色按钮
    UIReturnKeySend,标有Send的蓝色按钮
    UIReturnKeyYahoo,标有Yahoo的蓝色按钮
    UIReturnKeyYahoo,标有Yahoo的蓝色按钮
    UIReturnKeyEmergencyCall, 紧急呼叫按钮
//键盘外观
text.keyboardAppearance=UIKeyboardAppearanceDefault
    UIKeyboardAppearanceDefault， 默认外观，浅灰色
    UIKeyboardAppearanceAlert，　 　深灰 石墨色
//密码隐藏－安全输入模式
    textField.secureTextEntry = NO;//默认NO,得手动开启
//文本自适应
[textField sizeToFit];
//回收键盘
[textField resignFirstResponder];
```

### **UIButton**

```
UIButton *button = [UIButton buttonWithType:UIButtonTypeSystem];
//很多功能在选择系统风格时不能设置，所以尽量多写成自定义功能　　
	UIButtonTypeCustom = 0, 自定义风格
	UIButtonTypeRoundedRect, 圆角矩形
	UIButtonTypeDetailDisclosure, 蓝色小箭头按钮，主要做详细说明用
	UIButtonTypeInfoLight, 亮色感叹号
	UIButtonTypeInfoDark, 暗色感叹号
	UIButtonTypeContactAdd, 十字加号按钮
//设置button标题和标题颜色
[button setTitle:@"点击" forState:UIControlStateNormal];
[button setTitleColor:[UIColorredColor]forState:UIControlStateNormal];
	UIControlStateNormal = 0, 常规状态显现
	UIControlStateHighlighted = 1 << 0, 高亮状态显现
	UIControlStateDisabled = 1 << 1, 禁用的状态才会显现
	UIControlStateSelected = 1 << 2, 选中状态
button.titleLabel.font = [UIFont systemFontOfSize: 25];
按钮边框宽度及颜色
[button.layer setBorderWidth:1.0]; //边框宽度
[button.layer setBorderColor:[UIColor colorWithWhite:1.0 alpha:0.8].CGColor];
设置按钮按下会发光
button.showsTouchWhenHighlighted=NO;
//设置字体颜色  
[button setTintColor:[UIColor colorWithRed:0.16 green:0.16 blue:0.17 alpha:1]];  
//按钮背景颜色
button.backgroundColor = [UIColor colorWithRed:0.24 green:0.71 blue:0.87 alpha:1];
//圆角
button.layer.cornerRadius = 10;
button.clipsToBounds = YES;
//文字位置
btn.contentHorizontalAlignment = UIControlContentHorizonAlignmentLeft;
//但是问题又出来，此时文字会紧贴到做边框，我们可以设置
btn.contentEdgeInsets = UIEdgeInsetsMake(0,10, 0, 0);
//添加或删除事件处理
　　[button addTarget:self action:@selector(buttonTaped:) forControlEvents:UIControlEventTouchUpInside];
　　[button removeTarget:nil action:nil forControlEvents:UIControlEventTouchUpInside];
//设置button填充图片和背景图片
[buttonsetImage:[UIImageimageNamed:@"xx"]forState:UIControlStateNormal];
[buttonsetBackgroundImage:[UIImageimageNamed:@"xx"]forState:UIControlStateNormal];
//方法的延迟调用
[self performSelector:@selector(jump) withObject:nil afterDelay:2];
```

### **UIImage & UIImageView**

```
主要使用 png 和 jpg
通过路径获取图片
NSString *path = [[NSBundle mainBundle]resourcePath]; 工程路径
NSString *imagePath = [NSString stringWithFormat:@“%@/1.png”,path];
UIImage *image = [UIImage alloc]initWithContentsOfFile:imagePath]；
加载效率地，但是对内存需求低，针对比较大的图使用
通过名称获取图片
UIImage *image = [UIImage imageNamed:@“图片名(png),或者 图片名.jpg”];
这种方式的话，图片会被缓存到内存中，再次加载时，效率更高，当程序结束时，图片才会被释放，此方法对内存需求高
针对比较小而多的，而且使用次数多的图使用，比如qq表情包
图像旋转
UIImageOrientation myOrientation = Image.imageOrientation ;
可以设置以下方向：
typedef enum {
  UIImageOrientationUp,            // default orientation  默认方向
  UIImageOrientationDown,          // 180 deg rotation    旋转180度
  UIImageOrientationLeft,          // 90 deg CCW         逆时针旋转90度
  UIImageOrientationRight,         // 90 deg CW          顺时针旋转90度
  UIImageOrientationUpMirrored,    // as above but image mirrored along other axis. horizontal flip   向上水平翻转
  UIImageOrientationDownMirrored,  // horizontal flip    向下水平翻转
  UIImageOrientationLeftMirrored,  // vertical flip      逆时针旋转90度，垂直翻转
  UIImageOrientationRightMirrored, // vertical flip      顺时针旋转90度，垂直翻转
} UIImageOrientation;
图片载体UI-ImageView
显示的图片的大小和比例是由载体控制的，所以最好在设置载体时使用 image.size.width/height,这样就不会被拉变形
UIImageView *imageView = [[UIImageView alloc]initWithImage:image];
imageView.frame:CGRectMake(0 ,0 , 100, 100); 
注意:png格式的图片，镂空的地方会被设置为透明的，可以设置载体背景色
imageView.backgroundColor = [UIColor yellowColor];
圆角
imageView.layer.masksToBounds = YES;
imageView.layer.cornerRadius = 10;
边框
imageView.layer.borderColor = [UIColor orangeColor].CGColor;//颜色
imageView.layer.borderWidth = 2;//宽度
内容模式
imageView.contentMode = UIViewContentModeCenter; 
图片居中显示，图片会保持原图大小，不再强制改成载体大小，
默认ModeScaleToFill-拉伸充满整个载体
ModeScaleAspectFill-拉伸但是不改变比例，充满最大的一边
ModeScaleAspectFit -拉伸但是不改变比例，充满最小的一边
播放一系列图片
UIImage *image1 = [UIImage imageNamed:@“1”];
UIImage *image2 = [UIImage imageNamed:@“2”];
UIImage *image3 = [UIImage imageNamed:@“3”];
NSArray *imagesArray = @[image1,image2,image3];
imageView.animationImages = imagesArray;
// 设定所有的图片在多少秒内播放完毕
imageView.animationDuration = [imagesArray count];
// 不重复播放多少遍，0表示无数遍
imageView.animationRepeatCount = 0;
// 开始播放
[imageView startAnimating];
为图片添加单击事件：
一定要先将userInteractionEnabled置为YES，这样才能响应单击事件
imageView.userInteractionEnabled = YES;
UITapGestureRecognizer *singleTap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapImageView:)];
[imageView addGestureRecognizer:singleTap];
其他
imageView.hidden = YES或者NO;    // 隐藏或者显示图片
imageView.alpha =0.5;    // 设置透明度
设置高亮时显示的图片
imageView.highlightedImage = (UIImage *)hightlightedImage;
设置正常显示的图片
imageView.image = (UIImage *)image; 
```

### **UIScrollView**

```
//初始化scrollView
_scrollView = [[UIScrollView alloc]init];
_scrollView.bounds = CGRectMake(0, 0, SCREEN_W, 250);
_scrollView.center = self.view.center;
//设置滚动视图内容的大小,即用来盛放其他view的画布，必须比手机屏幕大才能有滚动效果
_scrollView.contentSize = CGSizeMake(SCREEN_W * 3, 250);
//设置分页
_scrollView.pagingEnabled = YES;
//是否显示指示条
_scrollView.showsHorizontalScrollIndicator = NO;
//加了导航栏后，会自动把滚动视图往下移动一个导航栏的高度，可手动关掉该效果
//关闭导航栏透视效果
self.automaticallyAdjustsScrollViewInsets = NO;
//初始化滚动视图中第一个视图－CGPoint类型
_scrollView.contentOffset = CGPointMake
_scrollView.contentOffset.x／y  可查看滚动视图当前所显示视图的坐标
//滚动响应方法得使用<UIScrollViewDelegate>协议中的方法
- (void)scrollViewDidScroll:(UIScrollView *)scrollView
//滚动视图的带动画的跳转,CGPoint类型，
[_scrollView setContentOffset:CGPointMake(x,x) animated:YES];
```

### **UIPageControl**

```
@property(nonatomic,strong)UIPageControl *pageControl;
//初始化分页控件
_pageControl = [[UIPageControl alloc]init];
_pageControl.bounds = CGRectMake(0, 0, SCREEN_W, 30);
_pageControl.center = CGPointMake(CGRectGetMidX(self.view.bounds), CGRectGetMidY(self.view.bounds) + 100);
//总页数
_pageControl.numberOfPages = 3;
//当前指示页
_pageControl.currentPage = 0;
//设置当前指示器小圆点颜色
_pageControl.currentPageIndicatorTintColor = [UIColor orangeColor];
[self.view addSubview:_pageControl];
```

### **UITableView**

```
//使用属性声明
@property(nonatomic,strong)UITableView *tableView;
//初始化表格视图
_tableView = [[UITableView alloc]initWithFrame:self.view.bounds style:UITableViewStylePlain];
_tableView.rowHeight = 50;
[self.view addSubview:_tableView];
//加载表格视图内容，设置延迟加载，为了效果
[self performSelector:@selector(loadDataSource) withObject:nil afterDelay:1];
//表格视图数据源为数组，通常进行属性申明为可变数组
//刷新表格，重新执行一遍数据源协议方法
[_tableView reloadData];

UITableViewDataSource协议
必须执行方法
//指定分区有多少行(默认只有一个分区)
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
	return 行数;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
  //table view的重用机制
  //1.声明一个可重用标识符
  static NSString *cellIdentifer = @"mycell";
  //2.从队列中拿出一个可重用的特殊cell
  UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellIdentifer];
  if (!cell) {
  //3.如果cell没有被初始化，则初始化它
  cell = [[UITableViewCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellIdentifer
  ];
}
//获取当前分区对应的字体数组
NSArray *fontArray = _dataDource[_allKeys[indexPath.section]];
  cell.textLabel.text = fontArray[indexPath.row];
  cell.textLabel.font = [UIFont fontWithName:fontArray[indexPath.row] size:16];
  return cell;
}
不必须执行方法
//设置表格有多少个分区
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{
	return 分区数;
}

UITableViewDelegate协议
按钮动态特效+push跳转
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
  //取消cell选中的颜色
  [tableView deselectRowAtIndexPath:indexPath animated:YES];
  //获取当前点击的cell
  UITableViewCell *cell = [tableView cellForRowAtIndexPath:indexPath];

  FontDetailViewController *fontDetail = [[FontDetailViewController alloc]init];
  fontDetail.fontName = cell.textLabel.text;
  [self.navigationController pushViewController:fontDetail animated:YES];
}
//设置分区高度
- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section
{
	return 30.0;
}
//设置分区标题
- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section
{
	return 标题;
}

下拉刷新动态旋钮
用属性申明
//下拉刷新控件(系统自带)
@property (nonatomic,strong)UIRefreshControl *refreshControl;
初始化
_refreshControl = [[UIRefreshControl alloc]init];
_refreshControl.attributedTitle = [[NSAttributedString alloc]initWithString: @"下拉刷新"];
添加响应控件
[_refreshControl addTarget:self action:@selector(beginRefreshData) forControlEvents:UIControlEventValueChanged];
[_tableView addSubview:_refreshControl];
开始进行
- (void)beginRefreshData{  }在其中写在刷新动画进行中进行的操作
停止进行  [_refreshControl endRefreshing];
```

### **UICollectionView**

```
//配置collectionview的布局
UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc]init];
//配置滚动方向
layout.scrollDirection = UICollectionViewScrollDirectionVertical;
                         UICollectionViewScrollDirectionVertical,垂直滚动
                         UICollectionViewScrollDirectionHorizontal 水平滚动
//设置item的尺寸
layout.itemSize = CGSizeMake(110, 110);
//item之间的最小间距
layout.minimumInteritemSpacing = 3;
//item之间的最小间距
layout.minimumLineSpacing = 10;
//设置header的尺寸
layout.headerReferenceSize = CGSizeMake(100, 30);//宽度默认与UICollectionViewFlowLayout一样
//设置footer的尺寸
layout.footerReferenceSize = CGSizeMake(100, 30);
//根据布局，初始化CollectionView
UICollectionView *collectionView = [[UICollectionView alloc]initWithFrame:self.view.bounds collectionViewLayout:layout];
//背景色
collectionView.backgroundColor = [UIColor colorWithRed:0.96 green:0.96 blue:0.96 alpha:1];
//设置内偏移量
collectionView.contentInset = UIEdgeInsetsMake(0, 10, 0, 10);
//注册cell
[collectionView registerClass:[CustomCollectionViewCell class] forCellWithReuseIdentifier:@"cell"];
//注册header - 可重用视图类
[collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionHeader withReuseIdentifier:@"header"];
//注册footer
[collectionView registerClass:[UICollectionReusableView class] forSupplementaryViewOfKind:UICollectionElementKindSectionFooter withReuseIdentifier:@"footer"];
//数据源协议
collectionView.dataSource = self;
collectionView.delegate = self;

[self.view addSubview:collectionView];

UICollectionViewDataSource协议
//item个数
- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section
{
    return _dataSource.count;
}

- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath
{
    //重用机制,此处标志符sell必须和上面标志符一样
    CustomCollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@"cell" forIndexPath:indexPath];
    //配置cell的显示
    //cell.backgroundColor = _dataSource[indexPath.row];
    return  cell;
}
```

### **UISwitch**

```
UISwitch *switchControl = [[UISwitch alloc]init];
switchControl.bounds = CGRectMake(0, 0, 60, 30);
switchControl.center = CGPointMake(CGRectGetMidX(self.view.bounds), CGRectGetMidY(self.view.bounds)-200);
设置开关是否开启－初始状态
switchControl.on = NO;
主色调-边框颜色
switchControl.tintColor = [UIColor greenColor];
开启区域的颜色
switchControl.onTintColor = [UIColor blueColor];
开关按钮颜色
switchControl.thumbTintColor = [UIColor yellowColor];
//开关点击事件
//开关本质上是值(bool)的改变
[switchControl addTarget:self action:@selector(controlProgress:) forControlEvents:UIControlEventValueChanged];
响应方法  判定 switchControl.on 是否为真来判定状态
```

### **UISegmentedControl**

```
UISegmentedControl *segmentedControl = [[UISegmentedControl alloc]initWithItems:@[@"white",@"blue",@"red"]];
通过数组存储要展示的部件
segmentedControl.bounds = CGRectMake(0, 0, 370, 30);
segmentedControl.center = self.view.center;
//设置默认选中项
segmentedControl.selectedSegmentIndex = 0;//对应数组下标
//设置字体颜色
segmentedControl.tintColor = [UIColor grayColor];
//设置字体颜色
//[segmentedControl setTitleTextAttributes:@{NSForegroundColorAttributeName:[UIColor blackColor]} forState:UIControlStateNormal];
[segmentedControl addTarget:self action:@selector(controlProgress:) forControlEvents:UIControlEventValueChanged];
响应方法
通过 segmentedControl.selectedSegmentIndex 获取对应下标，再新建数组来取对应值
NSArray *colors = @[[UIColor whiteColor],[UIColor blueColor],[UIColor redColor]];
self.view.backgroundColor = colors[segmentedControl.selectedSegmentIndex];
```

### **UISlider**

```
UISlider *slider = [[UISlider alloc]init];
slider.bounds = CGRectMake(0, 0, 335, 50);
slider.center = CGPointMake(CGRectGetMidX(self.view.bounds), CGRectGetMidY(self.view.bounds) - 120);
//设置最小／最大值
slider.minimumValue = 0.1;
slider.maximumValue = 1.0;
//初始值
slider.value = 0.5;
//最小／最大值颜色
slider.maximumTrackTintColor = [UIColor greenColor];
slider.minimumTrackTintColor = [UIColor grayColor];
[slider addTarget:self action:@selector(controlProgress:) forControlEvents:UIControlEventValueChanged];
```

### **UIProgressView**

```
@property(nonatomic,strong)UIProgressView *progressView;
_progressView = [[UIProgressView alloc]init];
_progressView.bounds = CGRectMake(0, 0, 300, 50);
_progressView.center = CGPointMake(CGRectGetMidX(self.view.bounds), CGRectGetMidY(self.view.bounds) + 100);
设置进度条风格样式
_progressView.progressViewStyle = UIProgressViewStyleDefault;
//UIProgressViewStyleDefault,
//UIProgressViewStyleBar
初始进度。默认0.0
_progressView.progress = 0.0;
走过部分颜色
_progressView.tintColor = [UIColor blueColor];
设置进度条进度和是否动画显示(动画显示会平滑过渡)
[_progressView setProgress:1.0 animated:YES];
```

### **UIStepper**

```
iOS中步进控件的简单使用
初始化控件
UIStepper *step = [[UIStepper alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];
设置控制器值是否连续触发变化
@property(nonatomic,getter=isContinuous) BOOL continuous;
若设置为YES，则长按会连续触发变化，若设置为NO，只有在按击结束后，才会触发。
设置长按是否一直触发变化
@property(nonatomic) BOOL autorepeat; 
若设置为YES，则长按值会一直改变，若设置为NO，则一次点击只会改变一次值
设置控制器的值是否循环(到达边界后，重头开始，默认为NO)
@property(nonatomic) BOOL wraps;
设置控制器的值
@property(nonatomic) double value; 
设置控制器的最大值和最小值
@property(nonatomic) double minimumValue;//默认为0
@property(nonatomic) double maximumValue; //默认为100
设置控制器的步长
@property(nonatomic) double stepValue; 
设置控制器风格颜色
@property(nonatomic,retain) UIColor *tintColor;
设置控制器背景图片
- (void)setBackgroundImage:(UIImage*)image forState:(UIControlState)state;
获取背景图片
- (UIImage*)backgroundImageForState:(UIControlState)state;
通过左右按钮的状态设置分割线的图片
- (void)setDividerImage:(UIImage*)image forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState;
获取分割线图片
- (UIImage*)dividerImageForLeftSegmentState:(UIControlState)state rightSegmentState:(UIControlState)state;
设置和获取加号按钮的图片
- (void)setIncrementImage:(UIImage *)image forState:(UIControlState)state;
- (UIImage *)incrementImageForState:(UIControlState)state;设置和获取减号按钮的图片
- (void)setDecrementImage:(UIImage *)image forState:(UIControlState)state;
- (UIImage *)decrementImageForState:(UIControlState)state;
```

### **UIAlertController**

```
UIAlertControllerStyleAlert  //弹出到中间
UIAlertControllerStyleActionSheet // 从下升起
UIAlertController *loginAlertController = [UIAlertController alertControllerWithTitle:@"提示" message:@"是否注销登录,注销后将无法使用部分功能" preferredStyle:UIAlertControllerStyleAlert];  
[loginAlertController addAction:[UIAlertAction actionWithTitle:@"确定" style:UIAlertActionStyleDestructive handler:^(UIAlertAction * _Nonnull action) {
}]];
[loginAlertController addAction:[UIAlertAction actionWithTitle:@"取消" style:UIAlertActionStyleCancel handler:nil]];
[self presentViewController:loginAlertController animated:YES completion:nil];
```

### UIActivityIndicatorView

```
@property (nonatomic,strong)UIActivityIndicatorView *indicatorView;
初始化活动指示器
_indicatorView = [[UIActivityIndicatorView alloc]initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleGray];
    UIActivityIndicatorViewStyleWhiteLarge, 大白
    UIActivityIndicatorViewStyleWhite,  白
    UIActivityIndicatorViewStyleGray     灰
    
_indicatorView.bounds = CGRectMake(0, 0, 30, 30);
_indicatorView.center = CGPointMake(CGRectGetMidX(self.view.bounds), CGRectGetMidY(self.view.bounds) + 150);
_indicatorView.backgroundColor = [UIColor blueColor];
设置背景透明
_indicatorView.alpha = 0.5;
设置背景为圆角矩形
_indicatorView.layer.cornerRadius = 6;
_indicatorView.layer.masksToBuounds = YES;
//当动画停止后是否自动隐藏控件
_indicatorView.hidesWhenStopped = YES;
[_indicatorView startAnimating]  开始
[_indicatorView stopAnimating] 停止
```

###  **UIDatePicker** 

```
@property (nonatomic,strong) UIDatePicker *datePicker;
//初始化
_datePicker = [ [ UIDatePicker alloc] initWithFrame:CGRectMake(0,447,375,220)];
_datePicker.backgroundColor = [UIColor groupTableViewBackgroundColor];
//显示项目
_datePicker.datePickerMode = UIDatePickerModeDateAndTime;
//时间间隔
_datePicker.minuteInterval = 1;
//时区
[_datePicker setLocale:[[NSLocale alloc]initWithLocaleIdentifier:@"zh_Hans_CN"]];
   
//获取选择时间
NSDate *pickDate = [_datePicker date];
NSDateFormatter *pickFormatter = [[NSDateFormatter alloc]init];
[pickFormatter setDateFormat:@"yy年MM月dd日－HH:mm:ss"];
NSString *dateString = [pickFormatter stringFromDate:pickDate];
_showLable.text = dateString;
```

### 